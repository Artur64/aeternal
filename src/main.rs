extern crate crypto;
extern crate hex;
extern crate blake2b;
extern crate rand;

extern crate regex;
extern crate http;

extern crate curl;
extern crate rust_base58;
extern crate rust_sodium;
#[macro_use]
extern crate serde_derive;
extern crate serde_json;

pub mod transaction;

#[macro_use]
extern crate diesel;
extern crate dotenv;
extern crate bigdecimal;
pub use bigdecimal::BigDecimal;

extern crate itertools;

extern crate futures;
extern crate hyper;


pub mod epoch;
pub mod schema;
pub mod server;
use server::MiddlewareServer;

pub mod models;

fn main() {
    let connection = epoch::establish_connection();
    
    let epoch = epoch::Epoch::new(String::from("http://localhost:3013"));
    println!("Top: {:?}", epoch.top().unwrap());
/*
    let top_response = epoch.top().unwrap();
    let mut top_hash = from_json(&top_response["hash"].to_string());
    populate_db(&connection, epoch, top_hash).unwrap();
*/
    let ms = MiddlewareServer {
        epoch: epoch,
        dest_url: String::from("http://localhost:3013"),
        port: 3013,
    };
    ms.start();
        
    
}

#[cfg(test)]
mod tests {
    use transaction::KeyPair;
    use get_last_block_id;
    #[test]
    fn test_read_sign_verify() {
        // Read a key pair from a file (these were generated by the JS
        // SDK so this also tests ineroperability. Sign and check
        // verification works
        let key_pair = KeyPair::read_from_files(&String::from("test/keys/testkey.pub"),
                                                &String::from("test/keys/testkey"),
                                                &String::from(""));
        let msg = b"this is a test thing";
        let mut bytes = key_pair.sign(msg).unwrap();
        println!("Sig: {:?}", KeyPair::bytes_to_hex(bytes));
        key_pair.verify(&bytes, msg).unwrap();
    }
    #[test]
    #[should_panic(expected = "Verification failed")]
    fn test_generate_sign_verify() {
        // generate 2 key pairs. Generate with one, verify with the
        // other. Should blow up!
        let key_pair = KeyPair::generate().unwrap();
        let new_key_pair = KeyPair::generate().unwrap();
        let msg  =b"this is a test thing";
        let bytes = new_key_pair.sign(msg).unwrap();
        key_pair.verify(&bytes, msg).unwrap();
    }

    #[test]
    fn test_write_sign_verify() {
        // generate a key pair, write it to a file. Read from the file
        // into a new variable, sign with one and check that
        // verification with the other works
        let new_key_pair = KeyPair::generate().unwrap();
        new_key_pair.write_to_files(&String::from("test/keys/new.pub"),
                                    &String::from("test/keys/new")).unwrap();
        let msg  =b"this is a test thing";
        let bytes = new_key_pair.sign(msg).unwrap();
        let loaded_key_pair = KeyPair::read_from_files(&String::from("test/keys/new.pub"),
                                                       &String::from("test/keys/new"),
                                                       &String::from(""));
        loaded_key_pair.verify(&bytes, msg).unwrap();
    }

    use diesel::prelude::*;
    use diesel::pg::PgConnection;
    use dotenv::dotenv;
    use std::env;
    
    pub fn establish_connection() -> PgConnection {
        dotenv().ok();
        
        let database_url = env::var("DATABASE_URL")
            .expect("DATABASE_URL must be set");
        PgConnection::establish(&database_url)
            .expect(&format!("Error connecting to {}", database_url))
    }

        
    #[test]
    fn test_save_block() {
        use Epoch;

        let epoch = Epoch::new(String::from("http://localhost:3013"));
        
        use models::InsertableBlock;
        let block = InsertableBlock {
            hash: String::from("bh$abcdef0123456789abcdef0123456789abcdef0123456789"),
            height: 123456,
            miner: String::from("ak$abcdef0123456789abcdef0123456789abcdef0123456789"),
            nonce: bigdecimal::BigDecimal::from(567876876876),
            prev_hash: String::from("bh$abcdef0123456789abcdef0123456789abcdef0123456789"),
            state_hash: String::from("sh$abcdef0123456789abcdef0123456789abcdef0123456789"),
            txs_hash: String::from("th$abcdef0123456789abcdef0123456789abcdef0123456789"),
            target: 12345676,
            time: 78798797987,
            version: 1,
        };
        let conn = establish_connection();
        use models::Block;
        let last_id = Block::max_id(&conn).unwrap();
        block.save(&conn);
        let id = get_last_block_id(&conn).unwrap();
        assert_eq!((last_id+1i32) as i64, id);
        
    }

    
}

